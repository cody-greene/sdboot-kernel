#!/usr/bin/env bash

BOOT=$(bootctl -p)
MACHINE_ID=$(cat /etc/machine-id)

if [[ -z ${MACHINE_ID} ]]; then
  echo "Error: Failed to get the machine-id"
  echo "see: man machine-id"
  exit 1
fi

usage() {
  echo "Usage: sdboot-kernel [action]"
  echo ""
  echo "Actions:"
  echo "  install  Generate mkinitcpio presets and install kernels, ucode & initramfs"
  echo "           to \$BOOT"
  echo "  remove   Remove orphaned kernels from \$BOOT and mkinitcpio presets"
  echo "           entries for other machine-ids are untouched"
  echo ""
  echo "\$BOOT = EFI system partiton; /efi, /boot or /boot/efi"
  echo ""
  echo "\$BOOT should be considered shared among all OS installations of a"
  echo "system. Instead of maintaining one \$BOOT per installed OS (as /boot/ was"
  echo "traditionally handled), all installed OS share the same place to drop in"
  echo "their boot-time configuration."
  exit 1
}

PRESET_TEMPLATE="
# generated by sdboot-kernel
ALL_config='/etc/mkinitcpio.conf'
ALL_kver='%VMLINUZ%'
PRESETS=('default')
default_image='%ENTRY_DIR_ABS%/initrd'
"

list_kernels() {
  kernels=() # output variable
  while read -r kernel; do
    kernels+=("${kernel}")
  done < <(find /usr/lib/modules -maxdepth 2 -type f -name vmlinuz)
}

# expects "usr/lib/modules/*/vmlinuz" on stdin
# otherwise searches for all installed kernels
run_install() {
  # Set /etc/kernel/cmdline to enable kernel-install in a chroot
  # but only if it does not already exist and only if not already in a chroot
  if [[ ! -e /etc/kernel/cmdline && "$(stat -c %d:%i /)" == "$(stat -c %d:%i /proc/1/root/.)" ]]; then
    read -r -d '' -a line </proc/cmdline
    BOOT_OPTIONS=""
    for i in "${line[@]}"; do
      [[ "${i#initrd=*}" != "$i" ]] && continue
      [[ "${i#BOOT_IMAGE=*}" != "$i" ]] && continue
      BOOT_OPTIONS+="$i "
    done
    echo ":: Creating /etc/kernel/cmdline"
    echo "${BOOT_OPTIONS}" >/etc/kernel/cmdline
  fi

  [[ ! -t 0 ]] || all=1

  kernels=()

  (( ! all )) && while read -r line; do
    [[ "$line" != */vmlinuz ]] && { all=1; break; }

    if ! read -r pkgbase > /dev/null 2>&1 < "/${line%/vmlinuz}/pkgbase"; then
      # if the kernel has no pkgbase, we skip it
      continue
    fi

    kernels+=("/${line}")
  done

  if (( all )); then
    list_kernels
  fi

  for kernel in "${kernels[@]}"; do
    version=$(basename "${kernel%/vmlinuz}")
    packagename=$(cat "${kernel%/vmlinuz}/pkgbase")
    preset_file="/etc/mkinitcpio.d/${packagename}.preset"
    entry_dir="${BOOT}/${MACHINE_ID}/${version}"

    echo ":: Generating ${preset_file}"
    subst="
      s|%ENTRY_DIR_ABS%|$entry_dir|g
      s|%VMLINUZ%|$kernel|g
    "
    mkdir -p "$entry_dir"
    echo -e "$PRESET_TEMPLATE" | sed "${subst}" | install -Dm644 /dev/stdin "$preset_file"

    echo ":: Running kernel-install for $version"
    kernel-install add "${version}" "${kernel}" /boot/*ucode.img initrd
  done
}

run_remove() {
  list_kernels
  (( ${#kernels[@]} )) &&
    expected_versions=$(basename -a "${kernels[@]%/vmlinuz}")
  expected_pkgbases=""
  for kernel in "${kernels[@]}"; do
    expected_pkgbases+=$(cat "${kernel%/vmlinuz}/pkgbase")$'\n'
  done

  # remove orphaned kernels from $BOOT
  for dir in "${BOOT}/${MACHINE_ID}"/*; do
    [[ -d "$dir" ]] || continue
    actual=$(basename "$dir")
    grep -Fxq "$actual" <<<"$expected_versions" || {
      echo ":: Removing ${actual}"
      kernel-install remove "${actual}"
    }
  done

  # remove orphaned presets
  for file in /etc/mkinitcpio.d/*.preset; do
    [[ -f "$file" ]] || continue
    actual=$(basename "$file" .preset)
    grep -Fxq "$actual" <<<"$expected_pkgbases" || {
      echo ":: Removing ${file}"
      rm -f "$file"
    }
  done
}

case $1 in
  install)
    run_install
    ;;
  remove)
    run_remove
    ;;
  *)
    usage
    ;;
esac
